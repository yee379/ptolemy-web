<div class="row row-fluid">
  <div class="row span12">
    <h1><span id="metric"></span></h1>
  </div>
  <div class="pull-right">
    <div id="autoupdate" class="btn-group">
      <button type="button" class="btn btn-default">Auto Update</button>
    </div>
    <div id="step" class="btn-group">
      <button type="button" class="btn btn-default" id='60'>1min</button>
      <button type="button" class="btn btn-default" id='300'>5min</button>
      <button type="button" class="btn btn-default" id='1800'>30min</button>
      <button type="button" class="btn btn-default" id='3600'>1hour</button>
      <button type="button" class="btn btn-default" id='10800'>3hour</button>
      <button type="button" class="btn btn-default" id='21600'>6hour</button>
    </div>
  </div>

  <div id="horizon" class="row span12"></div>
</div>

<%= coffee_script_tag do %>

# value_bits = [Infinity,-Infinity]

min = Infinity
max = -Infinity
calc_bits_extents = () ->
  i = 0
  n = this.context.size()
  value
  while (++i < n)
    value = this.valueAt(i);
    if (value < min) 
      min = value;
    if (value > max) 
      max = value;
  return [min, max];

get_group = ( metric ) ->
  # let's try to group the metrics to provide more meaningful data
  bits = metric.split('/')

  # port data should have all useful port statistics
  if bits[0] == 'port'
    
    # do some wrangling to remove ports with '/'
    if bits.length > 3
      metric = bits[0] + '/' + bits[1] + '/' + bits.slice(2,bits.length+1).join('.')
    
    return {
      delay: 60,
      step: 60,
      metrics: [
        {
          alias: 'bits-out'
          metric: metric.replace('port','port.util.out')
          # scale: d3.scale.linear().domain( [0,100] ).range( [0,1] )
          # extent: calc_bits_extents
          height: 100
          klass: 'up'
        },
        {
          alias: 'bits-in'
          metric: metric.replace('port','port.util.in')
          multiply: -1
          # scale: d3.scale.linear().domain( [0,100] ).range( [0,1] )
          # extent: calc_bits_extents
          height: 100
          klass: 'down'
        },
        {
          alias: 'unicastpkts-out'
          metric: metric.replace('port','port.unicastpkts.out')
          height: 30
          klass: 'up'
        },
        {
          alias: 'unicastpkts-in'
          metric: metric.replace('port','port.unicastpkts.in')
          multiply: -1
          height: 30
          klass: 'down'
        },
        {
          alias: 'broadcast-pkts-out'
          metric: metric.replace('port','port.broadcastpkts.out')
          height: 30
          klass: 'up'
        },
        {
          alias: 'broadcast-pkts-in'
          metric: metric.replace('port','port.broadcastpkts.in')
          multiply: -1
          height: 30
          klass: 'down'
        },
        {
          alias: 'multicast-pkts-out'
          metric: metric.replace('port','port.multicastpkts.out')
          multiply: 1
          height: 30
          klass: 'up'
        },
        {
          alias: 'multicast-pkts-in'
          metric: metric.replace('port','port.multicastpkts.in')
          multiply: -1
          height: 30
          klass: 'down'
        },

        {
          alias: 'crc-err'
          metric: metric.replace('port','port.err.in')
          height: 30
        },

        {
          alias: 'discards-out'
          metric: metric.replace('port','port.discards.out')
          height: 30
          klass: 'up'
        },
        {
          alias: 'discards-in'
          metric: metric.replace('port','port.discards.in')
          multiply: -1
          height: 30
          klass: 'down'
        },

        {
          alias: 'error-out'
          metric: metric.replace('port','port.error.out')
          height: 30
          klass: 'up'
        },
        {
          alias: 'error-in'
          metric: metric.replace('port','port.error.in')
          multiply: -1
          height: 30
          klass: 'down'
        },
      ]
    }
      
  else if bits[0] == 'subnet'
    return {
      delay: 300,
      step: 300,
      metrics: [
        {
          alias: 'loss'
          metric: metric.replace('subnet','subnet.loss')
          multiply: -1
          height: 50
        },
        {
          alias: 'hosts'
          metric: metric.replace('subnet','subnet.count')
          height: 50
        },
        {
          alias: 'min_rtt'
          metric: metric.replace('subnet','subnet.rtt')
          height: 50
        },
        {
          alias: 'jitter'
          metric: metric.replace('subnet','subnet.jitter')
          height: 50
        },
      ]
    }
      
  else if bits[0] == 'owamp'
    return {
      step: 300,
      delay: 300,
      metrics: [
        {
          alias: 'loss (fraction)'
          height: '35'
        },
        {
          alias: bits[1] + ' -> ' + bits[2]
          metric: bits[0].replace('owamp','owamp.loss')+'/'+bits[1]+'/'+bits[2]
          height: 50
        },
        {
          alias: bits[2] + ' -> ' + bits[1]
          metric: bits[0].replace('owamp','owamp.loss')+'/'+bits[2]+'/'+bits[1]
          multiply: -1
          height: 50
        },

        {
          alias: 'min (ms)'
          height: '35'
        },
        {
          alias: bits[1] + ' -> ' + bits[2]
          metric: bits[0].replace('owamp','owamp.min')+'/'+bits[1]+'/'+bits[2]
          height: 50
        },
        {
          alias: bits[2] + ' -> ' + bits[1]
          metric: bits[0].replace('owamp','owamp.min')+'/'+bits[2]+'/'+bits[1]
          multiply: -1
          height: 50
        },

        {
          alias: 'max-min (ms)'
          height: '35'
        },
        {
          alias: bits[1] + ' -> ' + bits[2]
          metric: bits[0].replace('owamp','owamp.jitter')+'/'+bits[1]+'/'+bits[2]
          multiply: -1
          height: 50
        },
        {
          alias: bits[2] + ' -> ' + bits[1]
          metric: bits[0].replace('owamp','owamp.jitter')+'/'+bits[2]+'/'+bits[1]
          multiply: -1
          height: 50
        }
      ]  
    }  
    
  else if bits[0] == 'bwctl'
    return {
      delay: 300,
      step: 3600,
      metrics: [
        {
          alias: 'throughput (bps)'
          height: '35'
        },
        {
          alias: bits[1] + ' -> ' + bits[2]
          metric: bits[0]+'/'+bits[1]+'/'+bits[2]
          height: 50
        },
        {
          alias: bits[2] + ' -> ' + bits[1]
          metric: bits[0]+'/'+bits[2]+'/'+bits[1]
          multiply: -1
          height: 50
        }
      ]
    }


  else if bits[0] == 'test'
    return {
      delay: 300,
      step: 3600,
      metrics: [
        {
          alias: bits[1] + ' -> ' + bits[2]
          metric: 'port.util.in/'+bits[1]+'/'+bits[2]
          # extent: [0,500000000]
          height: 250
        }
      ]
    }


  # default
  return {
    delay: 300,
    step: 300,
    metrics: [
      {
        metric: metric
        # scale: d3.scale.linear()
        height: 100   
      }   
    ]
  }

create_horizon = ( metrics, step, delay ) ->
  view = new HorizonView( '#horizon', delay=delay*1000, step=step*1000 )
  view.add metrics
  return view

jQuery ->

  get_delay = ( delay ) ->
    if $('#autoupdate button').hasClass( 'btn-primary' )
      return delay
    return 0

  metric = $(location).attr('href').replace( /^.+\/graphs(\.\w+)?\//, '' )
  $('span#metric').text( metric )

  # get defaults
  meta = get_group( metric )

  # set up bin sizes
  step = meta['step']
  $('#step button#'+step).addClass( 'btn-primary' )

  # initial
  view = create_horizon( meta['metrics'], step, get_delay( meta['delay'] ) )

  # change
  $('#step button').on( 'click', (e) ->
    # remove primary on others
    step = $(this)[0].id
    $('#step button').removeClass( 'btn-primary' )
    $(this).addClass( 'btn-primary' )
    view.destroy()
    view = create_horizon( meta['metrics'], step, get_delay( meta['delay'] ) )
  ) 

  # auto update
  $('#autoupdate button').on( 'click', (e) ->
    if $(this).hasClass( 'btn-primary' )
      $(this).removeClass( 'btn-primary' )
    else
      $(this).addClass( 'btn-primary' )
    view.destroy()
    view = create_horizon( meta['metrics'], step, get_delay( meta['delay'] ) )    
  )  




  # ctx = cubism.context()
  #     .serverDelay(600000)
  #     .step(600000)
  #     .size( $('#cubism').width() )  
  # 
  # d3.select("#cubism").selectAll(".axis")
  #     .data(["top", "bottom"])
  #   .enter().append("div")
  #     .attr("class", (d) -> d + " axis" )
  #     .each( (d) -> d3.select(@).call(ctx.axis().ticks(20).orient(d) ) )
  # d3.select("#cubism").append("div")
  #     .attr("class", "rule")
  #     .call( ctx.rule() )
  # 
  # 
  # 
  # # server = ctx.graphite()
  # server = ctx.ptolemy()
  # metrics = [ server.metric("network.kpi.subnet.prefix.134.79.77.128.len.25.rtt") ]
  # 
  # d3.select("#cubism").selectAll(".horizon")
  #     .data( metrics )
  #   .enter().insert("div", ".bottom")
  #     .attr("class", "horizon")
  #   .call(
  #     ctx.horizon()
  #   )

  
<% end %>
